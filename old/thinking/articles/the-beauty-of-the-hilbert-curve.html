<!DOCTYPE html>
<html>

<head>
	<title>The Beauty of the Hilbert Curve | Brandon Gong</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="shortcut icon" href="../../favicon.ico">
	<link
		href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;700&family=Source+Serif+Pro:ital,wght@0,400;0,700;1,300;1,400&display=swap"
		rel="stylesheet">
	<style>
		* {
			box-sizing: border-box;
		}

		html,
		body {
			padding: 0;
			margin: 0;
			width: 100%;
			height: 100%;
			cursor: none;
		}

		body {
			overflow-x: hidden;
			overflow-y: auto;
			scrollbar-width: none;
		}

		#icon {
			pointer-events: none;
		}

		body::-webkit-scrollbar {
			display: none;
		}

		.circle {
			position: absolute;
			border: solid 2px black;
			transition: border-color 200ms ease;
			width: 60px;
			height: 60px;
			/* border-radius: 50%; */
			transform: rotate(45deg);
			pointer-events: none;
			z-index: 1000;
		}

		#cursor-caption {
			position: absolute;
			pointer-events: none;
			color: #ffcc00;
			font-family: "Montserrat";
			font-weight: 600;
			font-size: 15px;
		}

		#smallcircle {
			height: 10px;
			width: 10px;
			background-color: black;
			border-radius: 50%;
			position: absolute;
			pointer-events: none;
			transition: background-color 200ms ease;
			z-index: 1000;
		}

		#nav {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			border-bottom: 1px solid #eee;
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			background-color: white;
			z-index: 100;
		}

		#x-close {
			font-size: 20px;
			text-decoration: none;
			cursor: none;
			padding: 15px;
			padding-right: 30px;
		}
		#x-close,
		#x-close:hover,
		#x-close:active,
		#x-close:visited {
			color: black;
		}

		a,
		a:hover,
		a:active,
		a:visited {
			text-decoration: none;
		}

		#nav-header {
			font-family: "Montserrat", sans-serif;
			font-weight: 700;
			font-size: 20px;
			white-space: nowrap;
			max-width: calc(100vw - 160px);
			text-overflow: ellipsis;
			overflow: hidden;
		}

		#wrapper {
			width: 100vw;
			display: flex;
			align-items: center;
			justify-content: center;
			margin-top: 120px;
		}

		#container {
			width: 800px;
			margin-bottom: 70px;
		}

		h1 {
			font-family: "Montserrat", sans-serif;
			font-weight: 700;
			font-size: 60px;
			margin-bottom: 0;
		}

		h2 {
			font-family: "Montserrat", sans-serif;
			font-weight: 300;
			font-size: 25px;
			color: #777;
		}

		#pfp {
			width: 80px;
			height: 80px;
			border-radius: 50%;
		}

		#name {
			font-family: "Montserrat", sans-serif;
			font-weight: 700;
			font-size: 25px;
		}

		#date {
			font-family: "Montserrat", sans-serif;
			font-weight: 300;
			font-size: 15px;
		}

		p {
			font-size: 22px;
			font-family: "Source Serif Pro", serif;
		}

		.img-caption {
			width: 100%;
			text-align: center;
			margin-top: 5px;
			font-family: "Source Serif Pro", serif;
			color: #888;
			font-style: italic;
			font-size: 18px;
		}

		::selection {
			background: #ffcc00;
			/* WebKit/Blink Browsers */
			color: black;
		}

		::-moz-selection {
			background: #ffcc00;
			/* Gecko Browsers */
			color: black;
		}

		.no-select {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		.drop {
			color: #ffcc00;
			float: left;
			font-weight: 700;
			font-size: 75px;
			line-height: 50px;
			padding-top: 4px;
			padding-right: 4px;
			padding-left: 3px;
		}

		#share {
			position: fixed;
			bottom: 90px;
			right: 25px;
			stroke-width: 0.2;
			transition: stroke 200ms ease,
						fill   200ms ease;
			fill: #000000;
			stroke: #000000;

		}
		#theme-toggle {
			position: fixed;
			bottom: 25px;
			right: 25px;
			transition: stroke 200ms ease,
						fill   200ms ease;
			stroke: #000000;
		}

		#progressbar {
			position: absolute;
			width: 0vw;
			height: 5px;
			bottom: -5px;
			left: 0px;
			background-color: #ffcc00;
		}

		.article-image {
			width: 80%;
			margin-left: 10%;
		}

		#share-wrapper {
			position: fixed;
			top: 0; left: 0;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0, 0, 0, 0.5);
			z-index: 101;
			align-items: center;
			justify-content: center;
			pointer-events: none;
			display: none;
		}
		#share-container {
			background-color: white;
			position: relative;
			display: flex;
			flex-direction: column;
			padding: 20px;
			justify-content: center;
			width: 50%;
			border-radius: 5px;
		}

		#copybtn {
			font-family: 'Montserrat', sans-serif;
			font-weight: 700;
			color: #ffcc00;
			border: 1px solid #ffcc00;
			padding: 11px 10px;
			font-size: 14px;
			transition: 200ms ease;
		}
		#copybtn:hover {
			font-family: 'Montserrat', sans-serif;
			color: white;
			border: 1px solid #ffcc00;
			padding: 11px 10px;
			font-size: 14px;
			background-color: #ffcc00;
		}

		#share-header {
			font-family: 'Montserrat', sans-serif;
			font-size: 30px;
			padding: 0;
			margin: 0;
			margin-bottom: 20px;
		}

		#share-components {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			width: 100%;
		}

		#urlcopy {
			background-color: white;
			border: 1px solid black;
			padding: 10px;
			font-family: 'Source Serif Pro', serif;
			font-size: 14px;
			flex-grow: 1;
			margin-right: 20px;
			min-width: 0;
			cursor: none;
		}

		#x-copy {
			position: absolute;
			top: 20px;
			right: 20px;
			font-size: 20px;
		}

		h3 {
			font-family: "Montserrat", sans-serif;
			font-size: 30px;
			margin-top: 50px;
			margin-bottom: 10px;
		}

		p > a.lighta, p > a.lighta:visited {
			color: black;
			text-decoration: underline;
			cursor: none;
		}

		p > a.darka, p > a.darka:visited {
			color: white;
			text-decoration: underline;
			cursor: none;
		}

		p > a.lighta:hover, p > a.lighta:active, p > a.darka:hover, p > a.darka:active {
			color: #ffcc00;
			text-decoration: underline;
			cursor: none;
		}

		@media only screen and (max-width: 1000px) {
			#container {
				width: calc(100vw - 70px);
			}
			#controls > #theme-toggle {
				position: unset;
			}
			#controls > #share {
				position: unset;
			}
		}

	</style>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

	<div id="nav">
		<a href="../../" style="cursor: none">
			<div id="logocontainer" style="padding: 15px; padding-top: 16px; padding-bottom: 14px;">
				<img src="../../Hilbert_curve_3.svg" width=32 id="icon">
			</div>
		</a>
		<div id="nav-header">The Beauty of the Hilbert Curve</div>
		<a onclick="window.history.back()">
			<div id="x-close" class="no-select">⨉</div>
		</a>
		<div id="progressbar"></div>
	</div>
	
	<div id="wrapper">
		<div id="container">
			<div class="no-select">
				<h1>The Beauty of the Hilbert Curve</h1>
				<h2>Plus, three ways to draw pseudo-Hilbert curves</h2>
				<div style="display: flex; flex-direction: row;align-items: center; margin-bottom: 50px;">
					<img src="profile.jpg" id="pfp">
					<div style="width: 15px"></div>
					<div>
						<div id="name">Brandon Gong</div>
						<div id="date">September 13th, 2020</div>
					</div>
					<div style="flex-grow: 1;"></div>
					<div id="controls">
						<svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="35" height="35" id="share" onclick="triggerCopy()"><path d="M14.5.5l.46.197a.5.5 0 00-.657-.657L14.5.5zm-14 6l-.197-.46a.5.5 0 00-.06.889L.5 6.5zm8 8l-.429.257a.5.5 0 00.889-.06L8.5 14.5zM14.303.04l-14 6 .394.92 14-6-.394-.92zM.243 6.93l5 3 .514-.858-5-3-.514.858zM5.07 9.757l3 5 .858-.514-3-5-.858.514zm3.889 4.94l6-14-.92-.394-6 14 .92.394zM14.146.147l-9 9 .708.707 9-9-.708-.708z"></path></svg>
						<svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="35" height="35" id="theme-toggle" onclick="todark()"><path d="M1.66 11.362A6.5 6.5 0 007.693.502a7 7 0 11-6.031 10.86z" stroke-linejoin="round"></path></svg>
					</div>
				</div>
			</div>
			<img src="001/hilbertprogression.png" class="article-image">
			<p class="img-caption">The first four orders of the pseudo-Hilbert curve.</p>
			<p>
				<span class="drop">A</span>s you browse my website, you may have picked up on a recurrent motif: a strange pattern,
				made of a singular line, zigging and zagging across a square canvas, folding over — but never crossing — itself.  These
				patterns are simplified representations of a fascinating type of geometry known as <i>space-filling curves.</i>  But to truly
				appreciate why they exist, we must go back in time.
			</p>
			<h3>Some Historical Context</h3>
			<p>
				<i>Germany, 1877</i>.  Georg Cantor, the father of set theory, makes a huge — and shocking — breakthrough: he finds that there is a
				<i>one-to-one</i> correspondence between points on a unit line segment and the points within a unit square.  In other words, you can
				pick out an arbitrary point in a square, and you can map it to a specific and unique number between 0 and 1.  His work would inspire
				other mathematicians to search for such a curve, which was thought impossible at the time.
			</p>
			<p>
				One such mathematician was Giuseppe Peano, who discovered his Peano curve in 1890.  His curve recursively subdivided squares into
				nine equal parts, and used a S-shaped primitive to build the space-filling curve.
			</p>
			<img src="001/peano.png" class="article-image" style="width: 50%; margin-left: 25%;">
			<p class="img-caption">The second iteration of the Peano curve.</p>
			<p>
				In 1891, David Hilbert improved upon Peano's curve by subdividing the square into four parts instead of nine, and using a simpler
				U-shape primitive.  And so the Hilbert curve was born; a continuous, infinitely-detailed fractal curve, snaking around the plane.
				The curve has some properties that make it actually useful in the real world; it is used in image editing, 3D rendering, and even
				in digital maps, where moving in some direction on the 2D map corresponds to shifting in some direction in one-dimensional memory.
				In parallel processing, the Hilbert curve can be used to schedule jobs between cores in order to optimize and cluster similar tasks
				in the same area.
			</p>
			<p>
				Because the Hilbert curve is a fractal, there is no real way to visualize the true Hilbert curve; instead, we draw
				simplified iterations of the curve, recursing only a few levels deep instead of infinitely.  These simplified representations are
				known as "pseudo-Hilbert curves", and the amount of recursion used to generate the curve is called the <i>order</i>.  Thus,
				higher-order pseudo-Hilbert curves are progressively more detailed and occupy more of the plane.  There are multiple algorithms
				that can be built to draw these pseudo-curves; let's look at a few of them below.
			</p>
			<h3>A Recursive Algorithm</h3>
			<p>
				The first and most obvious method that comes to mind for drawing pseudo-Hilbert curves is some sort of recursive method; after all, 
				the Hilbert curve is a fractal — an object that contains many smaller images of itself nested within itself.
			</p>
			<p>
				But what's the pattern? Well, if we take a closer look at pseudo-Hilbert curves, we can see that each successive order of 
				pseudo-Hilbert curve is simply four curves of the previous order, some rotated differently and then connected into one continuous 
				curve using three line segments.
			</p>
			<img src="001/labeledhilbert.png" class="article-image" style="width: 50%; margin-left: 25%;">
			<img src="001/labeledhilbert2.png" class="article-image" style="width: 50%; margin-left: 25%;">
			<p class="img-caption">A fourth-order curve being broken down into four third-order curves and then sixteen second-order curves.</p>
			<p>
				Thus, we can break down this drawing problem for any nth-order curve into four <code class="language-text">(n-1)</code>th order 
				sub-curves, and then each of those into four <code class="language-text">(n-2)</code>th order sub-sub-curves, and so on until we 
				reduce the problem into the most basic first-order case.
			</p>
			<p>
				Looking at the Hilbert curve superimposed over some x-y axes, we see that we also need to rotate the sub-curves in quadrants III and 
				IV clockwise and counterclockwise, respectively.
			</p>
			<img src="001/rotatehilbert.png" class="article-image" style="width: 50%; margin-left: 25%;">
			<p>
				Finally, we connect the four sub-curves with three line segments, using just a little bit of math to work those into the right 
				places.  The width of the line segments is the width of the curve or sub-curve divided by 2 raised to the order-th power.  It turns 
				out, as some basic math shows, that halving the width of each successive sub-curve as we recurse deeper while also decrementing the 
				order yields a constant, unchanging line segment length, despite each level of recursion working with different scales.
			</p>
			<p>
				The above process can be expressed quite succinctly with the below Javascript code, using <a href="https://p5js.org/" class="lighta">p5.js</a> to draw the lines.  For the sake of 
				consistency, I've wrapped the function that is actually called recursively,
				<code class="language-text">recursiveHilbertHelper</code>, inside another function that takes only two arguments —
				<code class="language-text">size</code> and <code class="language-text">order</code>,
				just like the arguments taken by the other implementations of curve drawing that I'll show 
				later — and fills in the rest of the initial values of the base case for the recursive function.
			</p>
			<p>
				Notice how <code class="language-text">recursiveHilbertHelper</code> calls itself four times, once for each subdivision.  Notice also how I make three calls to <code class="language-text">line</code> — the p5 function for drawing line segments — per function call.
			</p>
			<pre><code class="language-javascript">/*
 * Draw a pseudo-Hilbert curve recursively.
 */
let recursiveHilbert =
	(size, order) => recursiveHilbertHelper(size/2, size/2, size, order, 0);
			   
let recursiveHilbertHelper = (cx, cy, size, order, rot) => {
	push();
	translate(cx, cy);
	rotate(rot * PI / 2);
	if (order > 1) {
		let newC = size / 4;
		recursiveHilbertHelper(-newC, -newC, size / 2, order - 1, 0); // top left
		recursiveHilbertHelper(+newC, -newC, size / 2, order - 1, 0); // top right
		recursiveHilbertHelper(-newC, +newC, size / 2, order - 1, +1); // bottom left
		recursiveHilbertHelper(+newC, +newC, size / 2, order - 1, -1); // bottom right
	}
	
	// Connect the 4 quadrants together using 3 line segments.
	let n = 2 ** (order + 1);
	line(-size / n, -size / n, size / n, -size / n);
	line(-size * (0.5 - 1 / n), -size / n, -size * (0.5 - 1 / n), size / n);
	line(+size * (0.5 - 1 / n), -size / n, +size * (0.5 - 1 / n), size / n);
	pop();
};</code></pre>
			<h3>Lindenmayer Systems</h3>
			<img src="001/lsysex.jpg" class="article-image">
			<p class="img-caption">Some realistic plant-like formations generated using L-systems.  Unlike the one we use for Hilbert curves,
				this L-system achieves a less precise, more organic look via introducing randomness into the turtle's behavior, specifically into
				how much it turns or moves forward each step.  By <a href="http://www.erase.net/projects/l-systems/" class="lighta">Daniel John Jones</a>.
			</p>
			<p>
				Before I move on to a purely iterative algorithm for drawing pseudo-Hilbert curves, I would like to cover one more particularly 
				interesting way of drawing curves: via a Lindenmayer system.
			</p>
			<p>
				L-systems are sort of a middle ground between the recursive and the iterative worlds.  While our function doesn't call itself, as a 
				recursive function would, and also uses for-loops (as an iterative function would) instead of breaking down the problem into smaller 
				subproblems like we see with the previous implementation, at its heart it relies on a recursive-esque concept: text replacement.
			</p>
			<p>
				The idea is simple, but the vocabulary involved to describe it is a bit formal.  L-systems consist of three parts: a starting string, 
				called the "axiom", an "alphabet", or a set of characters that have some role, and "production rules", or a set of replacements that 
				describe how to manipulate the string. The "alphabet" is further broken down into "constants" and "variables"; "constants" are 
				characters that are not replaced and thus do not change, and "variables" are characters that are replaced as part of the production 
				rules.
			</p>
			<p>
				It's best to describe this using a simple example; let's say we have:
				<ul style="margin-top: -10px;font-size: 22px;font-family: 'Source Serif Pro', serif;">
					<li>An axiom (starting string) of <code class="language-text">"A"</code></li>
					<li>Two variables, <code class="language-text">A</code> and <code class="language-text">B</code></li>
					<li>Production rules of <code class="language-text">(A -> AB)</code> and <code class="language-text">(B -> A)</code>.</li>
				</ul>
			</p>
			<p>
				We start off with the starting string, or the "zeroth iteration" (n=0):
			</p>
			<pre><code class="language-text">A</code></pre>
			
			<p>
				For our first iteration, we look at the previous string and follow the production rules. Here, "A" maps to "AB".  This yields our 
				second iteration:
			</p>
			<pre><code class="language-text">AB</code></pre>
			
			<p>Following the same process, we map "A" to "AB" and "B" to "A" to produce the third iteration:</p>
			<pre><code class="language-text">ABA</code></pre>
			
			<p>...and then the fourth...</p>
			<pre><code class="language-text">ABAAB</code></pre>
			
			<p>...and then the fifth, sixth, and seventh:</p>
			<pre><code class="language-text"></code>ABAABABA
ABAABABAABAAB
ABAABABAABAABABAABABA</code></pre>
			
			<p>
				(As a side note: this is, in fact, Aristid Lindenmayer's original L-system for modeling the growth of a certain species of algae, 
				<i>Anabaena catenula</i>, in 1968.)
			</p>
			<p>
				You can see how each iteration is more complex than the last, and how we could use this system to build up complex patterns using 
				simple production rules.
			</p>
			<p>
			Looking back at the Hilbert curve, its nested, repetitive structure seems perfect for this kind of text-replacement approach.  So, what if we could use an L-system to generate instructions for drawing pseudo-Hilbert curves? And, what if we could find some set of production rules that would allow us to generate pseudo-curves of any order, simply by iterating the text replacement process more times?
			</p>
			<p>
				Spoiler alert: yes, such a ruleset exists.  And using that ruleset, we can generate instructions for pseudo-Hilbert curves of any order, and then interpret those instructions using <i>turtle graphics</i>.  Turtle graphics is a method of drawing in which you imagine a turtle walking across the page; you can tell it to take a step forward or turn, and it leaves a path behind it as it moves.
			</p>
			<p>
				The L-system for generating the curves is as below:
				<ul style="margin-top: -10px;font-size: 22px;font-family: 'Source Serif Pro', serif;">
					<li>Constants: <code class="language-text">F</code>, <code class="language-text">+</code>,
						<code class="language-text">-</code></li>
					<li>Variables: <code class="language-text">A</code>, <code class="language-text">B</code></li>
					<li>Axiom: <code class="language-text">"A"</code></li>
					<li>Production rules: <code class="language-text">(A -> − B F + A F A + F B −)</code>,
						<code class="language-text">(B -> + A F − B F B − F A +)</code></li>
				</ul>
			</p>
			<p>
				The turtle ignores the A's and B's when it follows the instructions.  F tells the turtle to take a step forward, - tells the turtle to turn 90° to the left, and + tells the turtle to turn 90° to the right.
			</p>
			<p>
				Okay, it looks a lot more complex and cryptic than the algae example from earlier, but if you look closer, it's not totally unrecognizable.
			</p>
			<p>
				If you look only at the constants, you can make out the basic primitive Hilbert curve shape in the production rules: the turtle moves forward, turns in some direction, moves forward again, turns again, and then moves forward one last time.
			</p>
			<p>
				Each time we build the next iteration of the L-system, we can create the next higher order pseudo-Hilbert curve. The first five iterations of our L-system are shown below.
			</p>
			<pre><code class="language-text">A
				
-BF+AFA+FB-

-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-

-+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+F+-+AF-BFB-FA+F+-BF
+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-F-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB
-+F+AF-BFB-FA+-+F+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+-

-+-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-F-+-BF+AFA+FB-F-+A
F-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+F+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-F
A+-F-BF+AFA+FB-+-F-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-+F
+-+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+F+-+AF-BFB-FA+F+-B
F+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-F-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+F
B-+F+AF-BFB-FA+-+F+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+-F
-+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+F+-+AF-BFB-FA+F+-BF
+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-F-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB
-+F+AF-BFB-FA+-+F+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+-+F
+-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-F-+-BF+AFA+FB-F-+AF
-BFB-FA+F+AF-BFB-FA+-F-BF+AFA+FB-+F+-BF+AFA+FB-F-+AF-BFB-FA+F+AF-BFB-FA
+-F-BF+AFA+FB-+-F-+AF-BFB-FA+F+-BF+AFA+FB-F-BF+AFA+FB-+F+AF-BFB-FA+-+-</code></pre>
			<p>
				The Javascript code for drawing a pseudo-Hilbert curve using an L-system is shared below.  Note how the first half generates the instructions, building up progressively more complex iterations using the text-replacement method described above, and the second half actually interprets these instructions by working step-by-step through the generated string.
			</p>
			<pre><code class="language-javascript">let lindenmayerHilbert = (size, order) => {
	// Generate instructions using L-system
	let axiom = "A";
	let rules = {
		'A': "-BF+AFA+FB-",
		'B': "+AF-BFB-FA+"
	};
	for (let i = 0; i < order; i++) {
		let next = "";
		for (let j = 0; j < axiom.length; j++) {
		let c = axiom.charAt(j);
		next += (rules[c]) ? rules[c] : c;
		}
		console.log(next);
		axiom = next;
	}
	
	// Interpret instructions using turtle
	let seglength = size / 2 ** order;
	let pos = createVector(seglength / 2, size - seglength / 2);
	let vel = createVector(seglength, 0);
	for (let i = 0; i < axiom.length; i++) {
		switch (axiom.charAt(i)) {
		case '-':
			vel.rotate(-PI / 2);
			break;
		case '+':
			vel.rotate(+PI / 2);
			break;
		case 'F':
			let x = pos.x,
			y = pos.y;
			pos.add(vel);
			line(x, y, pos.x, pos.y);
			break;
		}
	}
};</code></pre>
			<h3>
				A Purely Iterative Approach
			</h3>
			<p>
				The final way that we're going to look at is purely iterative.  There is no recursion, no breaking down the problem into four parts, 
				and no taking advantage of repeated nested structures, as our previous two algorithms used.
			</p>
			<p>
				Although usually I'm partial towards recursive solutions, purely because they tend to be more beautiful and concise while revealing 
				the deeper structure and core of the problem, I have to say that in this case this algorithm is my favorite of the three.
			</p>
			<p>
				Why? Well, with fractal patterns such as the Hilbert curve, recursive functions are the go-to way to attack problems.  This is simply 
				because these fractals are often hard to describe iteratively, much harder than it is to just take advantage of nested, recursive 
				structures and work from there.
			</p>
			<p>
				This algorithm, though, doesn't do any of that. Instead, it gives each vertex of the curve its own index - starting index 0 on the 
				bottom left. From there, it calculates the location of each point individually, without depending on the location of previously 
				calculated points.  And it does so using an incredibly simple observation: the location of each point is stored in the bits of its 
				index.
			</p>
			<img src="001/iterativex.svg" class="article-image">
			<p class="img-caption">A visualization of the iterative algorithm.  By
				<a href="https://marcin-chwedczuk.github.io/iterative-algorithm-for-drawing-hilbert-curve" class="lighta">Marcin Chwedczuk</a>.</p>
			<p>
				Breaking down a point's index into its binary representation, we actually find a pattern: looking at two bits at a time, we can
				figure out which quadrant contains the point in each sub-curve.  For example, in the above curve we can tell from the first two bits
				of 7<sub>dec</sub> (11<sub>bin</sub>) that the point is in quadrant IV of the first order sub-curve.  We can then tell from the next
				two bits (01<sub>bin</sub>) that the sub-curve as a whole is in quadrant II of the second order curve.
			</p>
			<p>
				So, by repeatedly shifting an index's binary representation to the right by two bits and then masking it with 3
				(0011<sub>bin</sub>), we can find the position of the point, and then the sub-sub-curve that contains that point, and then the 
				sub-curve that contains that sub-sub-curve, etc. until we reach the order of the curve we want to draw.  From there, accounting for
				the different rotation cases, we can add up the individual offsets of each sub-curves relative position until we obtain
				the absolute position of the point in x-y coordinates.
			</p>
			<p>
				(For a much more detailed description of the algorithm, the idea from the algorithm is shamelessly stolen from
				<a href="https://marcin-chwedczuk.github.io/iterative-algorithm-for-drawing-hilbert-curve" class="lighta">here</a>; my code is simply 
				a reimplementation of the process described there using p5.js).
			</p>
			<pre><code class="language-javascript">let iterativeHilbert = (size, order) => {
	let N = 2 ** order;
	let seglength = size / N;
	let points = [
	createVector(0, 0),
	createVector(0, 1),
	createVector(1, 1),
	createVector(1, 0)
	];
	let prev = createVector(seglength / 2, size - seglength / 2);
	for (let i = 0; i < N * N; i++) {
	let bits = i;
	let idx = bits & 3;
	let next = points[idx].copy();

	for (let j = 1; j < order; j++) {
		bits = bits >>> 2;
		idx = bits & 3;
		let offset = 2 ** j;
		let swap;
		switch (idx) {
		case 0:
			swap = next.x;
			next.x = next.y;
			next.y = swap;
			break;
		case 1:
			next.y += offset;
			break;
		case 2:
			next.x += offset;
			next.y += offset;
			break;
		case 3:
			swap = offset - next.x - 1;
			next.x = offset - next.y - 1;
			next.y = swap;
			next.x += offset;
			break;
		}
	}
	next.mult(seglength);
	next.add(seglength / 2, seglength / 2);
	next.y = size - next.y;
	line(prev.x, prev.y, next.x, next.y);
	prev = next;
	}
}</code></pre>
			<h3>Final Thoughts</h3>
			<p>So there we have it: three unique approaches to generating pseudo-Hilbert curves.</p>
			<p>
				Besides the concrete algorithms for pseudo-curves, I also think the idea behind a true Hilbert curve
				is fascinating — the fact that we can create a bijective map between the points along (0,1) and within
				n-dimensional space, to me, opens up only more questions in pure math that are still unsolved (or, maybe,
				unsearchable on the internet and not well-known).  But the curve also has applications outside pure math,
				in a wide range of different fields and different technologies which David Hilbert could never dream would
				exist.
			</p>
			<p>
				Why did I think this curve was so important that I included it as the icon throughout the website (with even the favicon
				being a second-order curve)?  Well, there are two reasons:
			</p>
			<p>
				For one, it is a reminder to me that there are always different ways to approach a problem.  In drawing these curves,
				we took three radically different approaches using completely different thought processes but still achieved the same result.
				Even in a problem that seems initially very concrete and limited like this one, there is still space for creativity
				and insight; I hope to keep this in mind as I tackle more problems later on and even in my daily life; how can, instead of
				clashing with someone of a different view, I rather reconcile their opinions as a valid alternative view to mine, with
				different background motivations and approaches?  How can I then process this information and add it to my own understanding
				of a topic to gain a more holistic, complete view?
			</p>
			<p>
				In addition, the Hilbert curve reminds me that something even as seemingly esoteric as itself can find unique and wide-ranging
				applications in unexpected areas.  Instead of just jumping to some default solution to a problem in my mind, I should take the
				time to process and think about other ways to approach it.  While I learn new concepts, I should also more actively try to
				link the new concepts with other areas of study in my mind so that I am more likely to notice these connections when I apply
				what I learn.
			</p>
		</div>
	</div>

	<div id="share-wrapper">
		<div id="share-container">
			<p id="share-header" class="no-select">Share this article</p>
			<div id="share-components">
				<input type="text" id="urlcopy" value="" readonly><br><br>
				<div id="copybtn" onclick="copyUrl()" class="no-select">Copy link</div>
			</div>
			<div class="no-select" onclick="detriggerCopy()" id="x-copy">⨉</div>
		</div>
	</div>


	<div id="cursor">
		<span id="smallcircle"></span>
		<span class="circle" id="circle"></span>
		<div id="cursor-caption"></div>
	</div>

	<style id="prism-styles">
		code[class*=language-],pre[class*=language-]{color:#575f66;background:0 0;font-family:Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#8a9199}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#8a9199}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:10px}:not(pre)>code[class*=language-],pre[class*=language-]{background:#fafafa}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#abb0b6}.token.punctuation{color:#575f66}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol{color:#a37acc}.token.tag{color:#55b4d4}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#86b300}.language-css .token.string,.style .token.string,.token.operator,.token.url{color:#ed9366}.token.entity{color:#399ee6}.token.atrule,.token.attr-value,.token.keyword{color:#fa8d3e}.token.class-name,.token.function{color:#399ee6}.token.important,.token.regex,.token.variable{color:#4cbf99}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}
	</style>
	<script src="../../js/jquery-3.5.1.min.js"></script>
	<script src="../../js/jquery.mousewheel.min.js"></script>
	<script src="prism.js"></script>
	<script>
		var isMobile = false;
		var labeloffset = 0;
		var smalloffset = 5;
		var toplabeloffset = 0;
		var isdark = false;

		$(document).ready(function () {
			(function (a) {
				if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i
					.test(a) ||
					/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
					.test(a.substr(0, 4))) isMobile = true;
			})(navigator.userAgent || navigator.vendor || window.opera);

			if (isMobile) {
				document.getElementById("cursor").style.display = "none";
			}

			var mouseX1 = 0,
				mouseY1 = 0;
			var xp = 0,
				yp = 0;

			document.getElementById("urlcopy").setAttribute("value", window.location.href);

			$(document).mousemove(function (e) {
				mouseX1 = e.pageX - 30;
				mouseY1 = e.pageY - 30;
				$('#smallcircle').css({
					left: e.pageX - smalloffset + 'px',
					top: e.pageY - smalloffset + 'px'
				});
			});

			$("#logocontainer").mouseenter(function () {
				document.getElementById("logocontainer").innerHTML =
					`<img src="../../Hilbert_curve_3_active.svg" width=32 id="icon">`;
			});
			$("#logocontainer").mouseleave(function () {
				if(isdark) {
					document.getElementById("logocontainer").innerHTML =
					`<img src="../../Hilbert_curve_3_white.svg" width=32 id="icon">`;
				} else {
					document.getElementById("logocontainer").innerHTML =
					`<img src="../../Hilbert_curve_3.svg" width=32 id="icon">`;
				}
				
			});
			$("#logocontainer").mousedown(function () {
				document.getElementById("logocontainer").innerHTML =
					`<img src="../../Hilbert_curve_3_active.svg" width=32 id="icon">`;
			});
			$("#x-close").mouseenter(function () {
				$("#circle").css({
					border: "solid 2px #ffcc00"
				});
				$("#smallcircle").css({
					backgroundColor: "#ffcc00"
				});
			});
			$("#x-close").mouseleave(function () {
				if(isdark) {
					$("#circle").css({
						border: "solid 2px white"
					});
					$("#smallcircle").css({
						backgroundColor: "white"
					});
				} else {
					$("#circle").css({
						border: "solid 2px black"
					});
					$("#smallcircle").css({
						backgroundColor: "black"
					});
				}
			});
			$("#x-copy").mouseenter(function () {
				$("#circle").css({
					border: "solid 2px #ffcc00"
				});
				$("#smallcircle").css({
					backgroundColor: "#ffcc00"
				});
			});
			$("#x-copy").mouseleave(function () {
				if(isdark) {
					$("#circle").css({
						border: "solid 2px white"
					});
					$("#smallcircle").css({
						backgroundColor: "white"
					});
				} else {
					$("#circle").css({
						border: "solid 2px black"
					});
					$("#smallcircle").css({
						backgroundColor: "black"
					});
				}
			});

			$("#share").mouseenter(function () {
				labeloffset = -145;
				$("#share").css({
					fill: "#ffcc00",
					stroke: "#ffcc00"
				});
				document.getElementById("cursor-caption").innerHTML = "Share&nbsp;this&nbsp;page";
				let sms = document.getElementById("smallcircle");
				if (sms) sms.parentNode.removeChild(sms);
				$("#smallcircle").css({
					width: "unset",
					height: "unset",
					backgroundColor: "unset"
				});
				document.getElementById("circle").style.borderColor = "#ffcc00";
				smalloffset = 15;
			});
			$("#share").mouseleave(function () {
				document.getElementById("cursor-caption").innerHTML = "";
				labeloffset = undefined;
				smalloffset = 5;
				let sms = document.getElementById("smallcircle");
				if (sms) sms.parentNode.removeChild(sms);
				document.getElementById("cursor").innerHTML = '<span id="smallcircle"></span>' + document
					.getElementById("cursor").innerHTML;
				toplabeloffset = 0;
				if(isdark) {
					$("#share").css({
						fill: "#ffffff",
						stroke: "#ffffff"
					});
					$("#smallcircle").css({
						width: "10px",
						height: "10px",
						backgroundColor: "white"
					});
					document.getElementById("circle").style.borderColor = "white";
				} else {
					$("#share").css({
						fill: "#000000",
						stroke: "#000000"
					});
					$("#smallcircle").css({
						width: "10px",
						height: "10px",
						backgroundColor: "black"
					});
					document.getElementById("circle").style.borderColor = "#000";
				}
			});
			$("#theme-toggle").mouseenter(function () {
				$("#theme-toggle").css({
					stroke: "#ffcc00"
				});
				labeloffset = -165;
				document.getElementById("cursor-caption").innerHTML = "Toggle&nbsp;dark&nbsp;mode";
				let sms = document.getElementById("smallcircle");
				if (sms) sms.parentNode.removeChild(sms);
				$("#smallcircle").css({
					width: "unset",
					height: "unset",
					backgroundColor: "unset"
				});
				document.getElementById("circle").style.borderColor = "#ffcc00";
				smalloffset = 15;
			});
			$("#theme-toggle").mouseleave(function () {
				document.getElementById("cursor-caption").innerHTML = "";
				labeloffset = undefined;
				smalloffset = 5;
				let sms = document.getElementById("smallcircle");
				if (sms) sms.parentNode.removeChild(sms);
				document.getElementById("cursor").innerHTML = '<span id="smallcircle"></span>' + document
					.getElementById("cursor").innerHTML;
				
				toplabeloffset = 0;
				if(isdark) {
					$("#theme-toggle").css({
						stroke: "#ffffff"
					});
					$("#smallcircle").css({
						width: "10px",
						height: "10px",
						backgroundColor: "white"
					});
					document.getElementById("circle").style.borderColor = "white";
				} else {
					$("#theme-toggle").css({
						stroke: "#000000"
					});
					$("#smallcircle").css({
						width: "10px",
						height: "10px",
						backgroundColor: "black"
					});
					document.getElementById("circle").style.borderColor = "#000";
				}
			});

			setInterval(function () {
				xp += ((mouseX1 - xp) / 6);
				yp += ((mouseY1 - yp) / 6);
				$("#circle").css({
					left: xp + 'px',
					top: yp + 'px'
				});
				if (labeloffset !== undefined) {
					$("#cursor-caption").css({
						left: xp + labeloffset + 'px',
						top: yp + +toplabeloffset + 20 + 'px'
					});
				}
			}, 20);

		});
		window.onscroll = function() {myFunction()};

		function myFunction() {
			var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
			var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
			var scrolled = (winScroll / height) * 100;
			document.getElementById("progressbar").style.width = scrolled + "vw";
		} 

		function todark() {
			isdark = true;
			$("body").css({
				backgroundColor: "#222222",
				color: "#d5d5d5"
			});
			$("#share").css({
				fill: "#ffffff",
				stroke: "#ffffff"
			});
			$("#nav").css({
				backgroundColor: "#1d1d1d",
				borderColor: "#1a1a1a"
			});
			$("#share-container").css({
				backgroundColor: "#222222"
			});
			$("#urlcopy").css({
				backgroundColor: "#1d1d1d",
				color: "white"
			});
			$("#x-close").css({color: "white"});
			Array.from(document.getElementsByClassName("lighta")).forEach(element => {
				element.classList.remove("lighta");
				element.classList.add("darka");
			});
			document.getElementById("logocontainer").removeChild(document.getElementById("icon"));
			document.getElementById("logocontainer").innerHTML = `<img src="../../Hilbert_curve_3_white.svg" width=32 id="icon">`;
			$("#prism-styles").text("code[class*=language-],pre[class*=language-]{color:#b3b1ad;background:0 0;font-family:Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#8a9199}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#8a9199}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:10px}:not(pre)>code[class*=language-],pre[class*=language-]{background:#191919}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#626a73}.token.punctuation{color:#b3b1ad}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol{color:#fe9}.token.tag{color:#39bae6}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#c2d94c}.language-css .token.string,.style .token.string,.token.operator,.token.url{color:#f29668}.token.entity{color:#ffb454}.token.atrule,.token.attr-value,.token.keyword{color:#fa8d3e}.token.class-name,.token.function{color:#59c2ff}.token.important,.token.regex,.token.variable{color:#95e6cb}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}");
			document.getElementById("theme-toggle").innerHTML = `<path d="M7.5 1.5v-1m0 13.99v-.998m6-5.997h1m-13 0h-1m2-4.996l-1-1m12 0l-1 1m-10 9.993l-1 1m12 0l-1-1m-2-4.997a2.999 2.999 0 01-3 2.998 2.999 2.999 0 113-2.998z" stroke-linecap="square"></path>`;
			document.getElementById("theme-toggle").setAttribute("onclick", "tolight()");
		}

		function tolight() {
			isdark = false;
			$("body").css({
				backgroundColor: "white",
				color: "black"
			});
			$("#share").css({
				fill: "#000000",
				stroke: "#000000"
			});
			$("#nav").css({
				backgroundColor: "white",
				borderColor: "#eee"
			});
			$("#share-container").css({
				backgroundColor: "white"
			});
			$("#urlcopy").css({
				backgroundColor: "white",
				color: "black"
			});
			$("#x-close").css({color: "black"});
			document.getElementById("logocontainer").removeChild(document.getElementById("icon"));
			document.getElementById("logocontainer").innerHTML = `<img src="../../Hilbert_curve_3.svg" width=32 id="icon">`;
			$("#prism-styles").text("code[class*=language-],pre[class*=language-]{color:#575f66;background:0 0;font-family:Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#8a9199}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#8a9199}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:10px}:not(pre)>code[class*=language-],pre[class*=language-]{background:#fafafa}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#abb0b6}.token.punctuation{color:#575f66}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol{color:#a37acc}.token.tag{color:#55b4d4}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#86b300}.language-css .token.string,.style .token.string,.token.operator,.token.url{color:#ed9366}.token.entity{color:#399ee6}.token.atrule,.token.attr-value,.token.keyword{color:#fa8d3e}.token.class-name,.token.function{color:#399ee6}.token.important,.token.regex,.token.variable{color:#4cbf99}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}");
			document.getElementById("theme-toggle").innerHTML = `<path d="M1.66 11.362A6.5 6.5 0 007.693.502a7 7 0 11-6.031 10.86z" stroke-linejoin="round"></path>`;
			document.getElementById("theme-toggle").setAttribute("onclick", "todark()");
		}

		function copyUrl() {
			document.getElementById("urlcopy").select();
			document.getElementById("urlcopy").setSelectionRange(0, 99999);
			document.execCommand("copy");
			document.getElementById("copybtn").innerHTML = "Copied!";
		}

		function triggerCopy() {
			$("#share-wrapper").css({
				pointerEvents: "unset",
				display: "flex"
			});
		}
		function detriggerCopy() {
			$("#share-wrapper").css({
				pointerEvents: "none",
				display: "none"
			});
		}
	</script>
</body>

</html>