<!DOCTYPE html>
<html lang="en">

<head>
	<title>Brandon Gong</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Vollkorn:wght@700&display=swap" rel="stylesheet"> 
	<style>
		* {
			box-sizing: border-box;
		}
		html,
		body {
			padding: 0;
			margin: 0;
			width: 100%;
			height: 100%;
			cursor: none;
		}
		body {
			overflow: hidden;
			scrollbar-width: none;
		}
		body::-webkit-scrollbar {
			display: none;
		}
		#content-container {
			position: absolute;
			color: white;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			display: flex;
			align-items: center;
			justify-content: center;
			pointer-events: none;
			font-size: 5vw;
			font-family: 'Montserrat';
		}
		#bigcontainer {
			display: flex;
			flex-direction: row;
			position: absolute;
			top: 0;
			left: 0;
		}
		#transitiongradient {
			height: 100vh;
			width: 400px;
			background: linear-gradient(90deg, rgba(187,187,187,1) 0%, rgba(37,37,37,1) 100%);
		}
		#box1 {
			background-color: #252525;
			width: 100vw;
			height: 100vh;
		}
		.circle {
			position: absolute;
		border: solid 1px white;
			width: 60px; 
			height: 60px; 
		/* border-radius: 50%; */
		transform: rotate(45deg);
		}
		#smallcircle {
			height: 10px;
			width: 10px;
			background-color: white;
			border-radius: 50%;
			position: absolute;
		}
	</style>
</head>

<body onload="logPosition(event)">

		<div id="container" onmousemove="logPosition(event)"></div>
	<img src="Hilbert_curve_3.svg" style="position: absolute; top: 20px; left: 20px;" width=80>
	<div id="content-container">
		<h1>brandon gong</h1>
	</div>

	<span class="circle" id="circle"></span>
	<span id="smallcircle"></span>

	<script src="js/three.min.js"></script>
	<script src="js/STLLoader.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/jquery-3.5.1.min.js"></script>
	<script src="js/jquery.mousewheel.min.js"></script>

	<script>
		var xpos = 0;

		$(document).ready(function() {

			var mouseX1 = 0, mouseY1 = 0;
			var xp = 0, yp = 0;
			
			$(document).mousemove(function(e){
				mouseX1 = e.pageX - 30;
				mouseY1 = e.pageY - 30;
				$('#smallcircle').css({left: e.pageX - 5 + 'px', top: e.pageY - 5 + 'px'});
			});
			
			setInterval(function(){
			xp += ((mouseX1 - xp)/6);
			yp += ((mouseY1 - yp)/6);
			$("#circle").css({left: xp +'px', top: yp +'px'});
			}, 20);

		});

		// $(document).ready(function() {
		// 	xpos = 0;
		// 	$("body").mousewheel(function(e, delta) {
		// 		xpos -= delta;
		// 		e.preventDefault();
		// 		if(xpos < -100) {
		// 			$("#bigcontainer").animate({
		// 				left: "+=50px"
		// 			}, 200)
		// 			xpos = 0
		// 		}
		// 	});
		// });

		var container, stats;

		var camera, cameraTarget, scene, renderer;

		var mouseX, mouseY, mx, my;


		init();
		animate();

		function logPosition(e) {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}

		function init() {

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 15);
			camera.position.set(3, 0.15, 3);

			cameraTarget = new THREE.Vector3(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xbbbbbb);
			scene.fog = new THREE.Fog(0xbbbbbb, 1.7, 2.0);

			var loader = new THREE.STLLoader();
			loader.load('./hilbert.stl', function (geometry) {

				var material = new THREE.MeshPhongMaterial({
					color: 0x030303,
					specular: 0x111111,
					shininess: 200
				});
				var mesh = new THREE.Mesh(geometry, material);

				mesh.rotation.set(Math.PI / 4, -Math.PI / 4, Math.PI / 4);
				mesh.scale.set(0.01, 0.01, 0.01);

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				scene.add(mesh);

			});

			// Lights

			addShadowedLight(1, 1, 1, 0xffffff, 1.35);
			addShadowedLight(0.5, 1, -1, 0xffffff, 1);
			// renderer

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputEncoding = THREE.sRGBEncoding;

			renderer.shadowMap.enabled = true;

			container.appendChild(renderer.domElement);

			window.addEventListener('resize', onWindowResize, false);

		}

		function addShadowedLight(x, y, z, color, intensity) {

			var directionalLight = new THREE.DirectionalLight(color, intensity);
			directionalLight.position.set(x, y, z);
			scene.add(directionalLight);

			directionalLight.castShadow = true;

			var d = 1;
			directionalLight.shadow.camera.left = -d;
			directionalLight.shadow.camera.right = d;
			directionalLight.shadow.camera.top = d;
			directionalLight.shadow.camera.bottom = -d;

			directionalLight.shadow.camera.near = 1;
			directionalLight.shadow.camera.far = 4;

			directionalLight.shadow.bias = -0.002;

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);

			render();

		}

		function render() {
			if(document.getElementById("menucontainer") !== null) return;

			// map mouseX, mouseY to [0, 2pi]
			if(my === undefined || isNaN(my)) {
				if(mouseX === undefined) {
					mouseX = window.innerWidth / 2;
					mouseY = window.innerHeight / 2;
				}
				mx = mouseX / window.innerWidth * 3.1415927 + 3.1415926535 / 2;
				my = (window.innerHeight - mouseY) / window.innerHeight * 3.1415927;
			} else {
				let nMx = mouseX / window.innerWidth * 3.1415927 + 3.1415926535 / 2;
				let nMy = (window.innerHeight - mouseY) / window.innerHeight * 3.1415927;
				mx = 0.95 * mx + 0.05 * nMx;
				my = 0.95 * my + 0.05 * nMy;
			}

			let pos = [Math.cos(mx), Math.sin(mx), Math.cos(my)];
			let norm = Math.sqrt(pos[0] * pos[0] + pos[1] * pos[1] + pos[2] * pos[2]);
			for (let i = 0; i < pos.length; i++) {
				pos[i] = pos[i] * 2 / norm;
			}

			let campos = new THREE.Vector3(0, 0, 0);
			camera.getWorldPosition(campos);

			let dx = [pos[0] - campos.x, pos[1] - campos.z, pos[2] - campos.y];

			// converge by some ratio each frame
			if(!isNaN(campos.x)) {
				camera.position.x += dx[0];
				camera.position.z += dx[1];
				camera.position.y += dx[2];
			} else {
				camera.position.x = pos[0];
				camera.position.z = pos[1];
				camera.position.y = pos[2];
			}
			


			camera.lookAt(cameraTarget);

			renderer.render(scene, camera);

		}
	</script>
</body>

</html>